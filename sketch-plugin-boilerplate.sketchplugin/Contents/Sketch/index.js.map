{"version":3,"sources":["webpack://exports/webpack/bootstrap","webpack://exports/./node_modules/@skpm/timers/test-if-fiber.js","webpack://exports/./node_modules/@skpm/timers/timeout.js","webpack://exports/./node_modules/cocoascript-class/lib/index.js","webpack://exports/./node_modules/cocoascript-class/lib/runtime.js","webpack://exports/./src/plugin/index.ts","webpack://exports/./src/plugin/utils/core.ts","webpack://exports/./src/plugin/utils/formatter.ts","webpack://exports/./src/plugin/utils/webview/index.ts","webpack://exports/./src/plugin/utils/webview/panel.ts","webpack://exports/./src/plugin/utils/webview/webview.ts","webpack://exports/./src/plugin/utils/webview/window.ts","webpack://exports/./src/shared.ts","webpack://exports/external \"sketch/async\"","webpack://exports/external \"sketch/dom\"","webpack://exports/external \"sketch/settings\""],"names":[],"mappings":";;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;;;;;;;;;;;;ACFA;AACA,qBAAqB,mBAAO,CAAC,qEAAiB;;AAE9C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yCAAyC,cAAc,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Da;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,eAAe,mBAAO,CAAC,qEAAc;;AAErC;;AAEA;AACA;;AAEA,6EAA6E,YAAY;;AAEzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7Da;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA,kCAAkC,qCAAqC;;AAEvE;AACA;AACA,4CAA4C,sCAAsC,GAAG,YAAY;AACjG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ,YAAY,WAAW;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,8GAA8G,YAAY,GAAG,YAAY,GAAG,aAAa,IAAI,UAAU,WAAW,GAAG;AACrL;AACA,8GAA8G,YAAY,GAAG,YAAY,GAAG,YAAY,IAAI,UAAU,WAAW,GAAG;;AAEpL;AACA,wCAAwC,gCAAgC,E;;;;;;;;;;;;ACvGxE,kDAAa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,eAAe,mBAAO,CAAC,gDAAc;AACrC,qBAAqB,mBAAO,CAAC,4DAAiB;AAC9C,YAAY,mBAAO,CAAC,8BAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,aAAa;AACzE;AACA;AACA;AACA;AACA,0DAA0D,aAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;AC1Da;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,EAAE,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZa;AACb;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,SAAS,mBAAO,CAAC,wDAAW;AAC5B,iBAAiB,mBAAO,CAAC,sDAAU;AACnC;AACA;AACA,gBAAgB,mBAAO,CAAC,oDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,2CAAS;AAChC,oBAAoB,mBAAO,CAAC,qDAAc;AAC1C,kBAAkB,mBAAO,CAAC,wDAAW;AACrC,iBAAiB,mBAAO,CAAC,wCAAiB;AAC1C,iBAAiB,mBAAO,CAAC,wCAAiB;AAC1C,YAAY,mBAAO,CAAC,8BAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gCAAgC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;;;;;;;;;;;;;ACzKa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,2CAAS;AAChC,4BAA4B,mBAAO,CAAC,wEAAmB;AACvD,cAAc,mBAAO,CAAC,kCAAc;AACpC,iBAAiB,mBAAO,CAAC,wCAAiB;AAC1C;AACA,cAAc,wBAAwB,8BAA8B,KAAK;AACzE;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA,sBAAsB,6BAA6B,IAAI,gBAAgB,gBAAgB,EAAE,GAAG;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3Fa;AACb,8CAA8C,cAAc;AAC5D,kBAAkB,mBAAO,CAAC,wDAAW;AACrC;AACA,2DAA2D;AAC3D;AACA,WAAW,iEAAiE;AAC5E;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;;;;;;;;;;;;;AClCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;;;;;;;;;;;;ACJA,yC;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,4C","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/plugin/index.ts\");\n","module.exports = function () {\n  return typeof coscript !== 'undefined' && coscript.createFiber\n}\n","/* globals coscript, sketch */\nvar fiberAvailable = require('./test-if-fiber')\n\nvar setTimeout\nvar clearTimeout\n\nvar fibers = []\n\nif (fiberAvailable()) {\n  var fibers = []\n\n  setTimeout = function (func, delay, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10) {\n    // fibers takes care of keeping coscript around\n    var id = fibers.length\n    fibers.push(coscript.scheduleWithInterval_jsFunction(\n      (delay || 0) / 1000,\n      function () {\n        func(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10)\n      }\n    ))\n    return id\n  }\n\n  clearTimeout = function (id) {\n    var timeout = fibers[id]\n    if (timeout) {\n      timeout.cancel() // fibers takes care of keeping coscript around\n      fibers[id] = undefined // garbage collect the fiber\n    }\n  }\n} else {\n  setTimeout = function (func, delay, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10) {\n    coscript.shouldKeepAround = true\n    var id = fibers.length\n    fibers.push(true)\n    coscript.scheduleWithInterval_jsFunction(\n      (delay || 0) / 1000,\n      function () {\n        if (fibers[id]) { // if not cleared\n          func(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10)\n        }\n        clearTimeout(id)\n        if (fibers.every(function (_id) { return !_id })) { // if everything is cleared\n          coscript.shouldKeepAround = false\n        }\n      }\n    )\n    return id\n  }\n\n  clearTimeout = function (id) {\n    fibers[id] = false\n  }\n}\n\nmodule.exports = {\n  setTimeout: setTimeout,\n  clearTimeout: clearTimeout\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SuperCall = undefined;\nexports.default = ObjCClass;\n\nvar _runtime = require(\"./runtime.js\");\n\nexports.SuperCall = _runtime.SuperCall;\n\n// super when returnType is id and args are void\n// id objc_msgSendSuper(struct objc_super *super, SEL op, void)\n\nconst SuperInit = (0, _runtime.SuperCall)(NSStringFromSelector(\"init\"), [], { type: \"@\" });\n\n// Returns a real ObjC class. No need to use new.\nfunction ObjCClass(defn) {\n  const superclass = defn.superclass || NSObject;\n  const className = (defn.className || defn.classname || \"ObjCClass\") + NSUUID.UUID().UUIDString();\n  const reserved = new Set(['className', 'classname', 'superclass']);\n  var cls = MOClassDescription.allocateDescriptionForClassWithName_superclass_(className, superclass);\n  // Add each handler to the class description\n  const ivars = [];\n  for (var key in defn) {\n    const v = defn[key];\n    if (typeof v == 'function' && key !== 'init') {\n      var selector = NSSelectorFromString(key);\n      cls.addInstanceMethodWithSelector_function_(selector, v);\n    } else if (!reserved.has(key)) {\n      ivars.push(key);\n      cls.addInstanceVariableWithName_typeEncoding(key, \"@\");\n    }\n  }\n\n  cls.addInstanceMethodWithSelector_function_(NSSelectorFromString('init'), function () {\n    const self = SuperInit.call(this);\n    ivars.map(name => {\n      Object.defineProperty(self, name, {\n        get() {\n          return getIvar(self, name);\n        },\n        set(v) {\n          (0, _runtime.object_setInstanceVariable)(self, name, v);\n        }\n      });\n      self[name] = defn[name];\n    });\n    // If there is a passsed-in init funciton, call it now.\n    if (typeof defn.init == 'function') defn.init.call(this);\n    return self;\n  });\n\n  return cls.registerClass();\n};\n\nfunction getIvar(obj, name) {\n  const retPtr = MOPointer.new();\n  (0, _runtime.object_getInstanceVariable)(obj, name, retPtr);\n  return retPtr.value().retain().autorelease();\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SuperCall = SuperCall;\nexports.CFunc = CFunc;\nconst objc_super_typeEncoding = '{objc_super=\"receiver\"@\"super_class\"#}';\n\n// You can store this to call your function. this must be bound to the current instance.\nfunction SuperCall(selector, argTypes, returnType) {\n  const func = CFunc(\"objc_msgSendSuper\", [{ type: '^' + objc_super_typeEncoding }, { type: \":\" }, ...argTypes], returnType);\n  return function (...args) {\n    const struct = make_objc_super(this, this.superclass());\n    const structPtr = MOPointer.alloc().initWithValue_(struct);\n    return func(structPtr, selector, ...args);\n  };\n}\n\n// Recursively create a MOStruct\nfunction makeStruct(def) {\n  if (typeof def !== 'object' || Object.keys(def).length == 0) {\n    return def;\n  }\n  const name = Object.keys(def)[0];\n  const values = def[name];\n\n  const structure = MOStruct.structureWithName_memberNames_runtime(name, Object.keys(values), Mocha.sharedRuntime());\n\n  Object.keys(values).map(member => {\n    structure[member] = makeStruct(values[member]);\n  });\n\n  return structure;\n}\n\nfunction make_objc_super(self, cls) {\n  return makeStruct({\n    objc_super: {\n      receiver: self,\n      super_class: cls\n    }\n  });\n}\n\n// Due to particularities of the JS bridge, we can't call into MOBridgeSupport objects directly\n// But, we can ask key value coding to do the dirty work for us ;)\nfunction setKeys(o, d) {\n  const funcDict = NSMutableDictionary.dictionary();\n  funcDict.o = o;\n  Object.keys(d).map(k => funcDict.setValue_forKeyPath(d[k], \"o.\" + k));\n}\n\n// Use any C function, not just ones with BridgeSupport\nfunction CFunc(name, args, retVal) {\n  function makeArgument(a) {\n    if (!a) return null;\n    const arg = MOBridgeSupportArgument.alloc().init();\n    setKeys(arg, {\n      type64: a.type\n    });\n    return arg;\n  }\n  const func = MOBridgeSupportFunction.alloc().init();\n  setKeys(func, {\n    name: name,\n    arguments: args.map(makeArgument),\n    returnValue: makeArgument(retVal)\n  });\n  return func;\n}\n\n/*\n@encode(char*) = \"*\"\n@encode(id) = \"@\"\n@encode(Class) = \"#\"\n@encode(void*) = \"^v\"\n@encode(CGRect) = \"{CGRect={CGPoint=dd}{CGSize=dd}}\"\n@encode(SEL) = \":\"\n*/\n\nfunction addStructToBridgeSupport(key, structDef) {\n  // OK, so this is probably the nastiest hack in this file.\n  // We go modify MOBridgeSupportController behind its back and use kvc to add our own definition\n  // There isn't another API for this though. So the only other way would be to make a real bridgesupport file.\n  const symbols = MOBridgeSupportController.sharedController().valueForKey('symbols');\n  if (!symbols) throw Error(\"Something has changed within bridge support so we can't add our definitions\");\n  // If someone already added this definition, don't re-register it.\n  if (symbols[key] !== null) return;\n  const def = MOBridgeSupportStruct.alloc().init();\n  setKeys(def, {\n    name: key,\n    type: structDef.type\n  });\n  symbols[key] = def;\n};\n\n// This assumes the ivar is an object type. Return value is pretty useless.\nconst object_getInstanceVariable = exports.object_getInstanceVariable = CFunc(\"object_getInstanceVariable\", [{ type: \"@\" }, { type: '*' }, { type: \"^@\" }], { type: \"^{objc_ivar=}\" });\n// Again, ivar is of object type\nconst object_setInstanceVariable = exports.object_setInstanceVariable = CFunc(\"object_setInstanceVariable\", [{ type: \"@\" }, { type: '*' }, { type: \"@\" }], { type: \"^{objc_ivar=}\" });\n\n// We need Mocha to understand what an objc_super is so we can use it as a function argument\naddStructToBridgeSupport('objc_super', { type: objc_super_typeEncoding });","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/// <reference types=\"sketch.d.ts\" />\n/// <reference types=\"../../typings/skpm\" />\nconst core_1 = require(\"./utils/core\");\nconst WebViewUtils = require(\"./utils/webview\");\nconst Dom = require(\"sketch/dom\");\n// These are just used to identify the window(s)\n// Change them to whatever you need e.g. if you need to support multiple\n// windows at the same time...\nconst windowIdentifier = 'sketch-plugin-boilerplate--window';\nconst panelIdentifier = 'sketch-plugin-boilerplate--panel';\n// All exported functions will be exposed as entry points to your plugin\n// and can be referenced in your `manifest.json`\nfunction helloWorld(context) {\n    core_1.initWithContext(context);\n    core_1.document.showMessage('👋🌏 Hello World!');\n}\nexports.helloWorld = helloWorld;\nfunction openWindow(context) {\n    // It's good practice to have an init function, that can be called\n    // at the beginning of all entry points and will prepare the enviroment\n    // using the provided `context`\n    core_1.initWithContext(context);\n    WebViewUtils.openWindow(windowIdentifier);\n}\nexports.openWindow = openWindow;\nfunction togglePanel(context) {\n    core_1.initWithContext(context);\n    WebViewUtils.togglePanel(panelIdentifier);\n}\nexports.togglePanel = togglePanel;\nfunction sendMessageToWindow(context) {\n    core_1.initWithContext(context);\n    WebViewUtils.sendWindowAction(windowIdentifier, 'foo', { foo: 'bar' });\n}\nexports.sendMessageToWindow = sendMessageToWindow;\nfunction sendMessageToPanel(context) {\n    core_1.initWithContext(context);\n    WebViewUtils.sendPanelAction(panelIdentifier, 'foo', { foo: 'bar' });\n}\nexports.sendMessageToPanel = sendMessageToPanel;\nfunction closeAllPanels(context) {\n    log('Close all panels due to document closed');\n    core_1.initWithContext(context);\n    WebViewUtils.closeActivePanels();\n}\nexports.closeAllPanels = closeAllPanels;\nfunction openActivePanels(context) {\n    log('open all active panels!');\n    setTimeout(() => {\n        if (!context.document) {\n            context.document = Dom.getSelectedDocument().sketchObject;\n        }\n        core_1.initWithContext(context);\n        WebViewUtils.openCurrentPanels();\n    }, 250);\n}\nexports.openActivePanels = openActivePanels;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet context = null;\nexports.context = context;\nlet document = null;\nexports.document = document;\nlet selection = null;\nexports.selection = selection;\nlet pluginFolderPath = null;\nexports.pluginFolderPath = pluginFolderPath;\nconst frameworkFolderPath = '/Contents/Resources/frameworks/';\nfunction getPluginFolderPath() {\n    // Get absolute folder path of plugin\n    const split = context.scriptPath.split('/');\n    split.splice(-3, 3);\n    return split.join('/');\n}\nfunction initWithContext(ctx) {\n    // This function needs to be called in the beginning of every entry point!\n    // Set all env variables according to current context\n    exports.context = context = ctx;\n    exports.document = document = ctx.document\n        || MSDocument.currentDocument();\n    exports.selection = selection = document ? document.selectedLayers() : null;\n    exports.pluginFolderPath = pluginFolderPath = getPluginFolderPath();\n    // Here you could load custom cocoa frameworks if you need to\n    // loadFramework('FrameworkName', 'ClassName');\n    // => would be loaded into ClassName in global namespace!\n}\nexports.initWithContext = initWithContext;\nfunction loadFramework(frameworkName, frameworkClass) {\n    // Only load framework if class not already available\n    if (Mocha && NSClassFromString(frameworkClass) == null) {\n        const frameworkDir = `${pluginFolderPath}${frameworkFolderPath}`;\n        const mocha = Mocha.sharedRuntime();\n        return mocha.loadFrameworkWithName_inDirectory(frameworkName, frameworkDir);\n    }\n    return false;\n}\nexports.loadFramework = loadFramework;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction toArray(object) {\n    if (Array.isArray(object)) {\n        return object;\n    }\n    const arr = [];\n    for (let j = 0; j < object.count(); j++) {\n        arr.push(object.objectAtIndex(j));\n    }\n    return arr;\n}\nexports.toArray = toArray;\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./webview\"));\nconst window_1 = require(\"./window\");\nexports.openWindow = window_1.open;\nexports.sendWindowAction = window_1.sendAction;\nconst panel_1 = require(\"./panel\");\nexports.togglePanel = panel_1.toggle;\nexports.openPanel = panel_1.open;\nexports.closePanel = panel_1.close;\nexports.isPanelOpen = panel_1.isOpen;\nexports.sendPanelAction = panel_1.sendAction;\nexports.closeActivePanels = panel_1.closeActivePanels;\nexports.openCurrentPanels = panel_1.openCurrentPanels;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"../core\");\nconst formatter_1 = require(\"../formatter\");\nconst webview_1 = require(\"./webview\");\nconst shared_1 = require(\"../../../shared\");\nconst Settings = require(\"sketch/settings\");\nconst Dom = require(\"sketch/dom\");\nconst OPEN_PANELS_KEY = 'open-panels';\nfunction toggle(identifier, path, width) {\n    if (isOpen(identifier)) {\n        close(identifier);\n    }\n    else {\n        open(identifier, path, width);\n    }\n}\nexports.toggle = toggle;\n/**\n * Closes active panels in the current document.\n */\nfunction closeActivePanels() {\n    const panels = Settings.settingForKey(OPEN_PANELS_KEY) || [];\n    for (const panel of panels) {\n        close(panel.id, false);\n    }\n}\nexports.closeActivePanels = closeActivePanels;\nfunction openCurrentPanels() {\n    log('Settings for key');\n    log(Settings.settingForKey(OPEN_PANELS_KEY));\n    const panels = Settings.settingForKey(OPEN_PANELS_KEY) || [];\n    for (const panel of panels) {\n        openPanel(panel.id, panel.path, panel.options);\n    }\n}\nexports.openCurrentPanels = openCurrentPanels;\n// TODO: Handle document closing (fiber should get released, probably)\nlet webview = null;\nfunction open(identifier, path = 'index.html', options = {}, openForAll = true) {\n    // get an absolute path\n    path = webview_1.getFilePath(path);\n    if (openForAll) {\n        // note that we opened this panel\n        const panels = Settings.settingForKey(OPEN_PANELS_KEY) || [];\n        if (!panels.find(panel => panel.id == identifier)) {\n            panels.push({ id: identifier, options, path });\n            Settings.setSettingForKey(OPEN_PANELS_KEY, panels);\n            log('Saved key');\n            log(panels);\n        }\n        // for each open document, open the panel\n        Dom.getDocuments().forEach((doc) => {\n            openPanel(identifier, path, options, doc.sketchObject);\n        });\n    }\n    else {\n        openPanel(identifier, path, options);\n    }\n}\nexports.open = open;\nfunction openPanel(identifier, path, options, doc) {\n    const { width } = options;\n    const frame = NSMakeRect(0, 0, width || 250, 600); // the height doesn't really matter here\n    doc = doc || core_1.document;\n    if (!doc) {\n        console.warn('Trying to open panel in document, but no document');\n        return;\n    }\n    if (!doc.documentWindow()) {\n        console.warn('Trying to open panel in document, but no document window');\n        return;\n    }\n    const contentView = doc.documentWindow().contentView();\n    if (!contentView || findWebView(identifier, doc)) {\n        return false;\n    }\n    const stageView = contentView.subviews().objectAtIndex(0);\n    webview = new webview_1.BridgedWebView();\n    webview.init(path, frame);\n    webview.view.identifier = identifier;\n    // if the fiber gets cleaned up, remove the panel\n    webview.fiber.onCleanup(() => {\n        // don't double clean up\n        if (!webview) {\n            return;\n        }\n        // clear the fiber reference so that it doesn't get far when triggered again\n        webview.fiber = null;\n        // remove the panel from the document\n        removePanel(identifier);\n    });\n    // TODO: Expose this for more general use\n    webview.onActionReceived = (name, payload) => {\n        console.log('Received ', name, payload);\n    };\n    // Inject our webview into the right spot in the subview list\n    const views = stageView.subviews();\n    const finalViews = [];\n    let pushedWebView = false;\n    for (let i = 0; i < views.count(); i++) {\n        const view = views.objectAtIndex(i);\n        finalViews.push(view);\n        // NOTE: change the view identifier here if you want to add\n        //  your panel anywhere else - view_canvas is the document area\n        if (!pushedWebView && view.identifier() == 'view_canvas') {\n            finalViews.push(webview.view);\n            pushedWebView = true;\n        }\n    }\n    // If it hasn't been pushed yet, push our web view\n    // E.g. when inspector is not activated etc.\n    if (!pushedWebView) {\n        finalViews.push(webview.view);\n    }\n    // Finally, update the subviews prop and refresh\n    stageView.subviews = finalViews;\n    stageView.adjustSubviews();\n}\nfunction close(identifier, closeForAll = true) {\n    if (closeForAll) {\n        // record the panel as closed\n        const panels = Settings.settingForKey(OPEN_PANELS_KEY) || [];\n        if (panels.find(panel => panel.id == identifier)) {\n            Settings.setSettingForKey(OPEN_PANELS_KEY, panels.filter(panel => panel.id != identifier));\n        }\n        // for each open document, close the panel\n        Dom.getDocuments().forEach((doc) => {\n            sendAction(identifier, shared_1.MESSAGE_TO_WV_CONTEXT, 'this.fiber.cleanup()', doc.sketchObject);\n        });\n    }\n    else {\n        // close just the current document\n        // send message to the original JS context that created the view and tell it to clean up\n        sendAction(identifier, shared_1.MESSAGE_TO_WV_CONTEXT, 'this.fiber.cleanup()');\n    }\n}\nexports.close = close;\nfunction removePanel(identifier) {\n    // Search for web view panel\n    const view = findWebView(identifier);\n    if (view) {\n        view.removeFromSuperview();\n    }\n    // clear variable for good measure\n    webview = null;\n}\nfunction isOpen(identifier) {\n    const panels = Settings.settingForKey(OPEN_PANELS_KEY) || [];\n    return !!panels.find(panel => panel.id == identifier);\n}\nexports.isOpen = isOpen;\nfunction findWebView(identifier, doc) {\n    doc = doc || core_1.document;\n    if (!doc || !doc.documentWindow()) {\n        return null;\n    }\n    const contentView = (doc || core_1.document).documentWindow().contentView();\n    if (!contentView) {\n        return null;\n    }\n    const splitView = contentView.subviews().objectAtIndex(0);\n    const views = formatter_1.toArray(splitView.subviews());\n    return views.find(view => view.identifier() == identifier);\n}\nexports.findWebView = findWebView;\nfunction sendAction(identifier, name, payload = {}, document) {\n    return webview_1.sendActionToWebView(findWebView(identifier, document), name, payload);\n}\nexports.sendAction = sendAction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"../core\");\nconst cocoascript_class_1 = require(\"cocoascript-class\");\nconst Async = require(\"sketch/async\");\nconst shared_1 = require(\"../../../shared\");\nfunction getFilePath(file) {\n    return `${core_1.pluginFolderPath}/Contents/Resources/webview/${file}`;\n}\nexports.getFilePath = getFilePath;\nfunction sendActionToWebView(webView, name, payload = {}) {\n    if (!webView || !webView.evaluateJavaScript_completionHandler) {\n        return;\n    }\n    // call the JS function exposed on window in the webview!\n    const script = `${shared_1.PLUGIN_TO_WV_BRIDGE}('${JSON.stringify({ name, payload })}');`;\n    webView.evaluateJavaScript_completionHandler(script, null);\n}\nexports.sendActionToWebView = sendActionToWebView;\nclass BridgedWebView {\n    constructor() {\n        this.fiber = null;\n        this.view = null;\n    }\n    initWithFile(file, frame) {\n        this.init(getFilePath(file), frame);\n    }\n    init(path, frame) {\n        const webView = this.createView(frame);\n        const url = NSURL.fileURLWithPath(path);\n        // log('File URL');\n        // log(url);\n        webView.setAutoresizingMask(NSViewWidthSizable | NSViewHeightSizable);\n        webView.loadRequest(NSURLRequest.requestWithURL(url));\n        this.view = webView;\n        // don't let the JS context get cleaned up while the panel is open\n        // consumers of the webview should add their own callbacks (to remove panel/close window)\n        this.fiber = Async.createFiber();\n    }\n    createView(frame) {\n        const config = WKWebViewConfiguration.alloc().init();\n        // enable right click -> inspect element\n        config.preferences()._developerExtrasEnabled = true;\n        // This is a helper delegate, that handles incoming bridge messages\n        const BridgeMessageHandler = cocoascript_class_1.default({\n            'userContentController:didReceiveScriptMessage:': (_controller, message) => {\n                try {\n                    const bridgeMessage = JSON.parse(String(message.body()));\n                    this.receiveAction(bridgeMessage.name, bridgeMessage.payload);\n                }\n                catch (e) {\n                    console.log('Could not parse bridge message', e, message.body());\n                    console.log('String of body: ', String(message.body()));\n                }\n            }\n        });\n        const messageHandler = BridgeMessageHandler.alloc().init();\n        config.userContentController().addScriptMessageHandler_name(messageHandler, shared_1.WV_TO_PLUGIN_BRIDGE);\n        const ViewClass = cocoascript_class_1.default({\n            classname: 'WebViewWrapper',\n            superclass: WKWebView,\n            ['viewWillMoveToSuperview:']: (view) => {\n                if (!view && this.fiber) {\n                    log('Cleaning up!');\n                    this.fiber.cleanup();\n                }\n            }\n        });\n        return ViewClass.alloc().initWithFrame_configuration(frame, config);\n    }\n    receiveAction(name, payload = {}) {\n        if (name == shared_1.MESSAGE_TO_WV_CONTEXT) {\n            try {\n                const func = new Function(payload);\n                func.call(this);\n            }\n            catch (e) {\n                console.warn('Unable to evaluate message to plugin', e, payload);\n            }\n            return;\n        }\n        if (this.onActionReceived) {\n            try {\n                this.onActionReceived(name, payload);\n            }\n            catch (e) {\n                console.warn('Unable to perform action received callback', e, payload);\n            }\n        }\n    }\n}\nexports.BridgedWebView = BridgedWebView;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst webview_1 = require(\"./webview\");\n// TODO: Update & handle window closing - https://github.com/skpm/sketch-module-web-view/blob/master/lib/set-delegates.js\nfunction open(identifier, path = 'index.html', options = {}) {\n    // Sensible defaults for options\n    const { width = 450, height = 350, title = 'Sketch Plugin Boilerplate' } = options;\n    const frame = NSMakeRect(0, 0, width, height);\n    const masks = NSTitledWindowMask |\n        NSWindowStyleMaskClosable |\n        NSResizableWindowMask;\n    const window = NSPanel.alloc().initWithContentRect_styleMask_backing_defer(frame, masks, NSBackingStoreBuffered, false);\n    window.setMinSize({ width: 200, height: 200 });\n    // We use this dictionary to have a persistant storage of our NSWindow/NSPanel instance\n    // Otherwise the instance is stored nowhere and gets release => Window closes\n    const threadDictionary = NSThread.mainThread().threadDictionary();\n    threadDictionary[identifier] = window;\n    const webView = new webview_1.BridgedWebView();\n    webView.init(path, frame);\n    window.title = title;\n    window.center();\n    window.contentView().addSubview(webView.view);\n    window.makeKeyAndOrderFront(null);\n}\nexports.open = open;\nfunction findWebView(identifier) {\n    const threadDictionary = NSThread.mainThread().threadDictionary();\n    const window = threadDictionary[identifier];\n    return window.contentView().subviews()[0];\n}\nexports.findWebView = findWebView;\nfunction sendAction(identifier, name, payload = {}) {\n    return webview_1.sendActionToWebView(findWebView(identifier), name, payload);\n}\nexports.sendAction = sendAction;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WV_TO_PLUGIN_BRIDGE = 'Sketch';\nexports.PLUGIN_TO_WV_BRIDGE = 'sketchBridge';\nexports.MESSAGE_TO_WV_CONTEXT = '__eval__';\n","module.exports = require(\"sketch/async\");","module.exports = require(\"sketch/dom\");","module.exports = require(\"sketch/settings\");"],"sourceRoot":""}